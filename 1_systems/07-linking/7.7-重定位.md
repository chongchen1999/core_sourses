Relocatable Object File（可重定位目标文件）是编译器输出的中间目标文件，尚未链接成最终的可执行文件或共享库。为了最终在链接时正确地安排各个代码和数据段的位置，需要 **重定位（Relocation）**。下面详细介绍重定位过程，包括：

---

## 一、重定位条目数据结构（Relocation Entry Structure）

在 ELF（Executable and Linkable Format）格式中，每个需要重定位的节（section）有一个对应的重定位节（relocation section），例如 `.rel.text`、`.rela.text`。

ELF 支持两种重定位条目结构：

### 1. `Elf32_Rel` / `Elf64_Rel`（无附加信息）

```c
typedef struct {
    Elf32_Addr r_offset; // 需要重定位的位置（偏移）
    Elf32_Word r_info;   // 符号索引和类型
} Elf32_Rel;
```

### 2. `Elf32_Rela` / `Elf64_Rela`（有附加信息）

```c
typedef struct {
    Elf32_Addr r_offset;  // 重定位位置
    Elf32_Word r_info;    // 符号和类型
    Elf32_Sword r_addend; // 附加值
} Elf32_Rela;
```

#### `r_info`字段的解释：

* 高位：指向符号表的索引（symbol table index）。
* 低位：重定位类型（如 R\_X86\_64\_PC32，R\_ARM\_ABS32 等）。

宏操作：

```c
#define ELF32_R_SYM(info)   ((info) >> 8)
#define ELF32_R_TYPE(info)  ((unsigned char)(info))
#define ELF32_R_INFO(sym, type) (((sym) << 8) + (unsigned char)(type))
```

---

## 二、重定位符号引用的详细过程

### 重定位的目标：

将代码或数据中的 **符号引用（如全局变量、函数）** 替换为正确的地址或偏移量。

---

### 重定位过程的步骤：

#### 1. **解析重定位节与目标节的对应关系**

每个 `.rel.text`、`.rela.text` 都与 `.text` 节相关，表示需要重定位的条目在哪些地方修改机器指令或数据。

#### 2. **查找符号表**

重定位条目中的 `r_info` 指向一个符号表条目（通常在 `.symtab` 中），比如全局变量 `extern int x`、函数 `foo()` 等。

* `.symtab` 表中包含了符号的名称、类型、绑定方式（本地、全局）、所在节、偏移等信息。

#### 3. **根据符号定位地址**

链接器使用符号名，在以下地方查找其地址：

* 当前对象文件的本地符号（定义在当前文件中）
* 被链接的其他对象文件中的符号
* 标准库或用户提供的静态/动态库中的符号

#### 4. **计算重定位值**

依据重定位类型（`R_*`）不同，计算方式也不同。常见的有：

| 重定位类型            | 说明                 | 值的计算方法      |
| ---------------- | ------------------ | ----------- |
| `R_X86_64_32`    | 绝对地址重定位，32位        | `S + A`     |
| `R_X86_64_PC32`  | PC 相对重定位，32位       | `S + A - P` |
| `R_X86_64_PLT32` | 指向 PLT 中的函数地址，相对地址 | `S + A - P` |
| `R_ARM_ABS32`    | ARM 绝对地址           | `S + A`     |
| `R_ARM_REL32`    | ARM 相对地址           | `S + A - P` |

其中：

* `S`: 符号的地址（由链接器解析）
* `A`: 重定位条目中提供的附加值（`r_addend`）
* `P`: 重定位位置的地址

#### 5. **写入重定位地址**

将计算出的重定位值写入 `r_offset` 指定的位置，替换原本的占位符（如立即数、偏移、地址等）。

---

### 示例说明：

假设有一段代码：

```c
extern int x;
int foo() {
    return x + 5;
}
```

编译为汇编后，在 `mov eax, [x]` 这样的指令中，`[x]` 的地址未知。

编译器会生成：

* `.rel.text` 包含一条 `R_X86_64_PC32` 或 `R_X86_64_32` 类型的重定位记录，指向 `x`。
* `r_offset` 是 `mov eax, [x]` 指令中需要修改的位置。
* 链接器解析 `x` 的地址为 0x60104c。
* 根据类型计算最终值，将其写入 `.text` 中。

---

## 小结

| 项目          | 描述                                                   |
| ----------- | ---------------------------------------------------- |
| **重定位条目结构** | `Elf32/64_Rel` 或 `Elf32/64_Rela`，包含重定位地址、符号索引、类型、附加值 |
| **重定位流程**   | 解析重定位节 → 查找符号表 → 计算重定位值 → 写入结果                       |
| **关键参与信息**  | `.rel.*`、`.symtab`、`.text/.data`、重定位类型（`R_*`）        |
| **最终目的**    | 在链接阶段替换代码或数据中的符号引用为正确地址，使程序可执行                       |

