`loader`（加载器）是操作系统中用于将**可执行文件（executable file）加载到内存中并准备运行**的一个关键组件。这个过程是程序从“文件”变成“进程”的关键步骤。下面详细分步骤介绍整个过程：

---

## 一、概述

当用户或系统发出运行一个程序的请求（如在命令行输入 `./a.out`），操作系统内核会调用 `execve()` 系统调用，启动 **Loader** 加载指定的可执行文件。整个加载流程包括：

1. **可执行文件格式识别与验证**
2. **创建进程地址空间**
3. **解析并加载各段（Segment）**
4. **处理动态链接（如使用共享库）**
5. **栈和堆的设置**
6. **设置入口点并跳转执行**

---

## 二、详细过程

### 1. **识别并验证可执行文件格式**

可执行文件通常有特定格式（如在 Linux 上是 ELF 格式）。Loader 首先：

* 检查魔数（magic number），如 ELF 的 `0x7F + "ELF"`
* 验证是否支持该架构（x86, ARM 等）
* 检查是否为有效的可执行文件（完整性、权限）

---

### 2. **创建新的进程地址空间**

操作系统为新程序创建干净的进程地址空间：

* 关闭旧的地址空间（如果是通过 `exec` 系列函数替换）
* 设置虚拟内存布局（内核态与用户态分区）
* 分配页表结构（或使用懒分配）

---

### 3. **解析并加载程序段（Program Headers）**

#### 以 ELF 文件为例：

可执行文件包含两个关键结构：

* **ELF Header**：描述文件类型、架构、入口点等
* **Program Header Table**：描述哪些部分需要加载到内存

Loader 会解析 Program Header：

* 将 `LOAD` 类型的 Segment 加载到对应的虚拟地址
* 如 `.text`（代码段）、`.data`（已初始化数据）、`.bss`（未初始化数据）
* 对于 `.bss`：仅在内存中清零，而不是从文件中读取

这些段通常会有以下权限映射：

| 段类型   | 内容     | 权限  |
| ----- | ------ | --- |
| .text | 可执行代码  | r-x |
| .data | 初始化数据  | rw- |
| .bss  | 未初始化数据 | rw- |

---

### 4. **处理动态链接（如动态库）**

如果程序依赖共享库（如 libc）：

* Loader 查找 `.interp` 段：指定用于动态链接的解释器路径（如 `/lib/ld-linux.so.2`）
* 由该解释器加载共享库（动态链接器自己是一个 ELF 程序）
* 加载所依赖的 `.so` 文件并完成符号解析和重定位
* 更新 GOT/PLT 表，构建符号跳转机制

---

### 5. **设置堆栈和堆**

* 分配用户栈空间（通常在虚拟地址的高端）

  * 初始化环境变量 `environ[]`
  * 参数 `argv[]`
  * 程序名 `argv[0]`
* 初始化堆空间（用于 `malloc` 动态内存分配）

  * 设置 `brk` 起始位置

---

### 6. **设置入口点并跳转执行**

Loader 最后一步：

* 读取 ELF Header 中的 `e_entry` 字段（入口地址）
* 设置好程序计数器（如 EIP/RIP）指向入口地址
* 将控制权转交给用户程序的入口点
* 程序开始运行（从 `main()` 或 `_start()` 开始）

---

## 三、简化版流程图

```
exec() 系统调用
     ↓
验证 ELF 格式
     ↓
清空旧进程地址空间 / 创建新进程空间
     ↓
加载程序段到虚拟内存
     ↓
调用动态链接器（如需要）
     ↓
设置栈（argv/envp）和堆
     ↓
跳转到入口地址 e_entry
     ↓
开始执行用户代码
```

---

## 四、一些额外细节

* **按需加载（Lazy loading）**：有的操作系统采用“按需页加载”，初次访问段内容时才加载进内存。
* **ASLR（地址空间布局随机化）**：为了安全，Loader 会随机化堆、栈、共享库的加载地址。
* **Copy-on-write（写时复制）**：对于 `fork()` + `exec()` 场景，会延迟复制内存页，优化性能。
* **内核与用户模式切换**：加载完成后，CPU 切换到用户模式执行程序代码。

---

## 五、总结

Loader 是可执行文件生命周期的关键桥梁。它从硬盘上读取可执行文件的内容，准备虚拟内存空间，完成段加载、堆栈配置与动态链接，并最终启动程序运行。理解这个流程对于学习操作系统、系统编程、逆向工程、甚至安全攻防都有很大帮助。
