# x86-64汇编寻址方法、mov指令及栈操作（AT&T风格）

## 寻址方法

x86-64 寻址模式一览表（AT&T语法）

| 寻址模式         | 语法示例               | 说明                                                                 |
|----------------------|---------------------------|-------------------------------------------------------------------------|
| 立即数寻址       | `movq $42, %rax`          | 操作数是直接值（如 `$42`），不涉及内存访问。                              |
| 寄存器寻址       | `movq %rbx, %rax`         | 操作数是寄存器（如 `%rbx`），直接在寄存器间传递数据。                      |
| 直接寻址         | `movq 0x1000, %rax`       | 通过绝对地址（如 `0x1000`）访问内存，需完整地址（64位模式下较少见）。       |
| 寄存器间接寻址   | `movq (%rbx), %rax`       | 内存地址由寄存器（如 `%rbx`）的值指定。                                   |
| 基址+偏移寻址    | `movq 8(%rbx), %rax`      | 内存地址 = 基址寄存器（`%rbx`） + 固定偏移（如 `8`）。                      |
| 变址寻址        | `movq (%rsi,%rdi), %rax`  | 内存地址 = 基址寄存器（`%rsi`） + 变址寄存器（`%rdi`）。                    |
| 比例变址寻址    | `movq (%rsi,%rdi,4), %rax`| 内存地址 = 基址（`%rsi`） + 变址（`%rdi`） * 比例因子（`1/2/4/8`）。         |
| RIP相对寻址      | `movq 0x20(%rip), %rax`   | 内存地址 = `%rip`（当前指令指针） + 固定偏移（用于位置无关代码）。           |

---

关键说明
1. 比例因子：仅支持 `1`、`2`、`4`、`8`（对应字节、字、双字、四字）。  
2. RIP相对寻址：64位模式特有，常用于访问全局变量或跳转表。  
3. 段寄存器：64位模式下通常忽略（除 `%fs`/`%gs` 用于线程局部存储）。  

---

示例代码片段（AT&T语法）
```asm
movq  (%rbx), %rax         # 寄存器间接寻址
movq  16(%rsp), %rcx       # 基址（栈指针）+ 偏移
movl  (%rsi,%rdi,4), %edx  # 比例变址寻址（数组访问）
leaq  label(%rip), %rax    # RIP相对寻址（获取标签地址）
```

## mov指令

x86-64 `mov` 指令一览表（AT&T语法）

| 指令格式               | 示例                     | 操作数类型          | 说明                                                                 |
|---------------------------|-----------------------------|-----------------------|-------------------------------------------------------------------------|
| 立即数 → 寄存器        | `movq $42, %rax`            | 立即数 → 寄存器        | 将常数 `42` 存入 `%rax`（64位）。                                       |
| 寄存器 → 寄存器        | `movq %rbx, %rax`           | 寄存器 → 寄存器        | 将 `%rbx` 的值复制到 `%rax`。                                            |
| 内存 → 寄存器          | `movq (%rsp), %rax`         | 内存 → 寄存器          | 从栈顶（`%rsp`指向的地址）读取数据到 `%rax`。                            |
| 寄存器 → 内存          | `movq %rdi, -8(%rbp)`       | 寄存器 → 内存          | 将 `%rdi` 的值存入栈帧局部变量（`%rbp-8`）。                             |
| 立即数 → 内存          | `movq $0x1234, (%rbx)`      | 立即数 → 内存          | 将 `0x1234` 写入 `%rbx` 指向的64位内存（需指定大小后缀，如 `movq`）。     |
| 符号扩展（movs）       | `movsbq (%rsi), %rax`       | 8/16位 → 64位（带符号） | 将字节（8位）符号扩展为64位存入 `%rax`。                                |
| 零扩展（movz）         | `movzbl (%rdi), %eax`       | 8/16位 → 32/64位（无符号） | 将字节零扩展为32位存入 `%eax`（高位补零）。                             |
| lea（地址计算）        | `leaq (%rbx,%rsi,4), %rax`  | 内存地址 → 寄存器       | 计算地址并存入 `%rax`（不访问内存，仅地址运算）。                       |

---

关键说明
1. 操作数大小：  
   • 通过指令后缀表示：`b`（字节，8位）、`w`（字，16位）、`l`（双字，32位）、`q`（四字，64位）  
   • 如 `movl %ebx, %eax` 是32位，`movq %rbx, %rax` 是64位  

2. 符号扩展 vs 零扩展：  
   • `movs`系列：用于有符号数（如 `movsbw` 字节→字，`movslq` 双字→四字）  
   • `movz`系列：用于无符号数（如 `movzwl` 字→双字）  

3. `lea` 与 `mov` 区别：  
   • `leaq` 计算地址但不访问内存（如 `leaq 8(%rbx), %rax` 等价于 `rax = rbx + 8`）  
   • `mov` 会实际读取或写入内存数据  

4. 限制：  
   • 不能内存 → 内存（需通过寄存器中转）  
   • 立即数必须带 `$` 前缀  

---

示例代码（AT&T语法）
```asm
movq  $0x1234, %rax        # 立即数 → 寄存器
movq  %rax, (%rbx)         # 寄存器 → 内存
movsbq (%rcx), %rdx        # 符号扩展加载
leaq  (%rax,%rdx,2), %rsi  # 计算数组元素地址（无内存访问）
```

## 入栈出栈指令

x86-64 栈操作指令一览表（AT&T语法）

| 指令 | 语法 | 操作数类型 | 功能描述 | 注意事项 |
|---------|---------|--------------|-------------|-------------|
| push | `pushq %reg` | 寄存器（64位） | 将寄存器值压入栈顶 | 1. 自动调整 `%rsp`<br>2. 64位模式下默认操作64位数据 |
| | `pushq $imm` | 立即数（32位） | 将立即数压入栈顶 | 1. 会自动符号扩展为64位<br>2. 不支持64位立即数直接push |
| | `pushq mem` | 内存地址 | 将内存数据压入栈顶 | 需要指定操作数大小（如 `pushq var`） |
| pop | `popq %reg` | 寄存器（64位） | 从栈顶弹出数据到寄存器 | 1. 自动调整 `%rsp`<br>2. 64位模式下默认操作64位数据 |
| | `popq mem` | 内存地址 | 从栈顶弹出数据到内存 | 需要指定操作数大小（如 `popq var`） |

---

关键说明
1. 栈指针（RSP）行为：
   • `pushq` 会先将 `%rsp` 减8，然后将数据存入 `(%rsp)`  
   • `popq` 会先读取 `(%rsp)` 的数据，然后将 `%rsp` 加8  

2. 操作数大小处理：
   • 64位模式下 `pushq`/`popq` 默认操作64位数据  
   • `pushq $imm` 只能接受32位立即数（会自动符号扩展）  

3. 特殊限制：
   • 不能直接 `popq` 到 `%rip`  
   • 内存操作必须明确大小（如 `pushq (%rax)`）  

4. 常用场景：
   • 函数调用时保存寄存器（`pushq %rbp`）  
   • 分配栈空间（`subq $16, %rsp`）和释放（`addq $16, %rsp`）  

---

示例代码（AT&T语法）
```asm
# 保存寄存器
pushq %rax      # 将%rax压栈
pushq $42       # 将立即数42压栈（自动扩展为64位）

# 恢复寄存器
popq %rbx       # 栈顶数据弹出到%rbx
popq var        # 栈顶数据弹出到内存

# 函数序言/尾声
my_function:
    pushq %rbp       # 保存调用者的%rbp
    movq %rsp, %rbp  # 建立新栈帧
    ...
    popq %rbp        # 恢复调用者的%rbp
    retq
```

---

注意事项
1. AT&T语法中操作数顺序是 `源, 目的`（与Intel语法相反）  
2. 立即数必须带 `$` 前缀，寄存器带 `%` 前缀  
3. 内存引用用 `()` 表示，如 `(%rsp)`  
4. 指令后缀表示操作数大小（如 `movb`、`movw`、`movl`、`movq`）