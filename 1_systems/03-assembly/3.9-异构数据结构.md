# 以下是 x86-64 架构中与异构数据结构（结构体、联合体、数据对齐）相关的关键指令

---

**1. 结构体（Struct）相关指令**
结构体在汇编中表现为连续的内存块，通过基址寄存器+偏移量访问成员。

| 指令                | 功能描述                          | ATT 语法示例                     | 说明                                                                 |
|---------------------|-----------------------------------|----------------------------------|----------------------------------------------------------------------|
| `mov`               | 成员访问                          | `movl 4(%rbp), %eax`             | 从 `%rbp+4` 处加载 4 字节到 `%eax`（假设结构体第 2 个成员为 `int`） |
| `lea`               | 计算成员地址                      | `leaq 8(%rdi), %rax`             | 计算 `%rdi`（结构体基址）+8 的地址，存到 `%rax`                     |
| `movaps`/`movapd`   | 对齐的 SIMD 数据移动              | `movaps 16(%rsi), %xmm0`         | 从对齐的地址加载 16 字节到 `%xmm0`（用于 SSE 对齐结构体成员）        |

---

**2. 联合体（Union）相关指令**
联合体成员共享同一内存地址，访问时需显式指定数据类型。

| 指令                | 功能描述                          | ATT 语法示例                     | 说明                                                                 |
|---------------------|-----------------------------------|----------------------------------|----------------------------------------------------------------------|
| `mov`               | 访问不同大小的成员                | `movb (%rdi), %al`               | 读取联合体的第一个字节（`char` 类型成员）                            |
| `movl`              | 同一地址的不同类型解释            | `movl (%rdi), %eax`              | 将同一地址解释为 4 字节 `int` 类型                                   |
| `movq`              | 8 字节成员访问                    | `movq (%rdi), %rax`              | 读取联合体的 8 字节（如 `double` 或 `int64_t`）                      |

---

**3. 数据对齐（Alignment）相关指令**
对齐指令确保数据访问符合硬件要求（如 SSE 需要 16 字节对齐）。

| 指令                | 功能描述                          | ATT 语法示例                     | 说明                                                                 |
|---------------------|-----------------------------------|----------------------------------|----------------------------------------------------------------------|
| `align` 伪指令       | 声明对齐边界                      | `.align 16`                      | 后续数据按 16 字节对齐（编译器指令，非硬件指令）                     |
| `movaps`/`movapd`   | 要求对齐的 SIMD 移动              | `movaps %xmm0, (%rsp)`           | 若 `%rsp` 未对齐 16 字节，会触发异常                                 |
| `movups`/`movupd`   | 不要求对齐的 SIMD 移动            | `movups (%rcx), %xmm1`           | 允许非对齐访问，但性能较低                                           |
| `palignr` (SSE)     | 对齐数据拼接                      | `palignr $8, %xmm1, %xmm0`       | 将 `%xmm1` 和 `%xmm0` 的数据按偏移 8 字节对齐合并                    |

---

**4. 其他相关指令**
| 指令                | 功能描述                          | ATT 语法示例                     | 说明                                                                 |
|---------------------|-----------------------------------|----------------------------------|----------------------------------------------------------------------|
| `push`/`pop`        | 栈操作（影响结构体/联合体传递）   | `pushq %rbx`                     | 保存寄存器到栈（可能用于结构体参数传递）                             |
| `cmpxchg`           | 原子比较交换（用于共享数据）      | `lock cmpxchgq %rcx, (%rdi)`     | 原子更新结构体/联合体成员（多线程场景）                              |

---

**关键注意事项**
1. 对齐要求：SSE/AVX 指令（如 `movaps`）要求地址对齐，否则会触发 `#GP` 异常。
2. 联合体访问：同一内存地址的不同解释需通过不同大小的 `mov` 指令实现。
3. 结构体填充：编译器可能插入填充字节以满足对齐，需在高级语言中用 `__attribute__((packed))` 控制。
