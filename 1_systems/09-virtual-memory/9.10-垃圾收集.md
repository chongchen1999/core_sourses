# 垃圾收集与Mark & Sweep垃圾收集器

垃圾收集(Garbage Collection, GC)是一种自动内存管理机制，负责识别和回收不再被程序使用的内存空间。下面我将详细介绍垃圾收集的概念和Mark & Sweep算法。

## 垃圾收集的基本概念

垃圾收集是一种自动内存管理技术，它能够:
- 追踪哪些对象正在被程序使用
- 自动识别不再使用的对象("垃圾")
- 回收这些对象占用的内存空间以供重用

没有垃圾收集的语言(如C/C++)需要程序员手动管理内存分配和释放，这容易导致内存泄漏或悬挂指针等问题。

## Mark & Sweep算法

Mark & Sweep(标记-清除)是最基础也是最经典的垃圾收集算法之一，由John McCarthy在1960年为Lisp语言发明。该算法分为两个主要阶段:

### 1. 标记阶段(Mark Phase)

- 从"根对象"(root objects)开始，这通常包括全局变量、栈上的局部变量和寄存器等
- 沿着对象引用关系进行深度优先或广度优先遍历
- 标记所有可达对象(reachable objects)为"活动"
- 任何未被标记的对象被视为"垃圾"

### 2. 清除阶段(Sweep Phase)

- 扫描整个堆内存
- 释放所有未被标记的对象
- 将这些对象占用的内存空间返回给内存分配器

## Mark & Sweep的优缺点

### 优点
- 相对简单易实现
- 可以处理循环引用问题(互相引用的对象)

### 缺点
- 执行过程中需要暂停程序运行(Stop-The-World)
- 可能导致内存碎片化
- 清除阶段需要扫描整个堆，效率较低

## Mark & Sweep的改进版本

### 三色标记法(Tri-color Marking)
更现代的实现通常使用三色标记:
- 白色：未被访问的对象
- 灰色：已访问但其引用尚未完全检查的对象
- 黑色：已访问且其所有引用都已检查的对象

### 增量式垃圾收集(Incremental GC)
- 将标记和清除过程分解为多个小步骤
- 减少GC导致的程序暂停时间

### 并发垃圾收集(Concurrent GC)
- 允许垃圾收集与应用程序同时运行
- 需要特殊机制确保正确性

## 应用Mark & Sweep的编程语言

许多现代编程语言和运行时使用基于Mark & Sweep的垃圾收集器或其变种:
- JavaScript (V8, SpiderMonkey等引擎)
- Python
- Ruby
- Java (部分收集器)
- .NET框架
- Go语言

## 总结

Mark & Sweep垃圾收集算法是自动内存管理的基础，它通过标记所有可达对象并清除未标记对象来回收内存。尽管有一些固有缺点，它依然是许多现代垃圾收集器的基础，并通过各种优化手段不断改进以提高性能和减少程序暂停时间。